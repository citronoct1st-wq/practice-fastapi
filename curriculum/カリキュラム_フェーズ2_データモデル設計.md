# FastAPI × PostgreSQL フェーズ2 データモデル設計 カリキュラム

## フェーズ2の目標

✅ SQLAlchemy ORM モデルの定義方法を習得
✅ Pydantic スキーマの使用方法を理解
✅ ユーザー管理テーブルの実装
✅ データベーステーブルの自動生成

---

## 学習内容の流れ

```
フェーズ1完了（DB接続確認）
        ↓
フェーズ2 ← 今ここ
├─ Step 1: モデル設計（テーブル設計図作成）
├─ Step 2: models.py 作成（SQLAlchemyモデル定義）
├─ Step 3: schemas.py 作成（Pydanticスキーマ定義）
├─ Step 4: テーブル自動生成（Base.metadata.create_all）
└─ Step 5: 動作確認
        ↓
フェーズ3: CRUD エンドポイント実装
```

---

## Step 1: モデル設計（テーブル設計図作成）

### 目的
ユーザー管理テーブル「users」の構造を設計します。

### テーブル仕様（users テーブル）

```
┌────────────────────────────────────────┐
│            users テーブル               │
├────────────────────────────────────────┤
│ カラム名     │ データ型   │ 制約         │
├────────────────────────────────────────┤
│ id          │ Integer    │ PK, Auto     │
│ name        │ String     │ NOT NULL     │
│ email       │ String     │ NOT NULL     │
│             │            │ UNIQUE       │
│ created_at  │ DateTime   │ NOT NULL     │
│             │            │ Default: now │
└────────────────────────────────────────┘
```

### 各カラムの説明

| カラム | 型 | 説明 |
|--------|-----|------|
| `id` | Integer | プライマリキー。自動採番される一意の識別子 |
| `name` | String | ユーザー名。NULL不可 |
| `email` | String | メールアドレス。NULL不可、重複禁止（UNIQUE） |
| `created_at` | DateTime | 作成日時。自動的に現在時刻が設定される |

### 制約の重要性

```
UNIQUE制約 on email
└─ 同じメールアドレスで2つのユーザーアカウントが作成されない
   例：yamada@example.com は1つだけ登録可能

NOT NULL制約
└─ nameやemailが空（NULL）になることを防ぐ

PrimaryKey制約
└─ idで各ユーザーを一意に識別
```

---

## Step 2: models.py 作成（SQLAlchemy モデル定義）

### 作成ファイル名
`models.py`

### 役割
SQLAlchemy ORM モデルを定義します。Pythonのクラスがテーブルに対応します。

### 実装コード

```python
from sqlalchemy import Column, Integer, String, DateTime, func
from datetime import datetime
from database import Base

class User(Base):
    """ユーザーモデル"""

    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, nullable=False, index=True)
    created_at = Column(DateTime, nullable=False, default=func.now())

    def __repr__(self):
        """デバッグ用の表示"""
        return f"<User(id={self.id}, name={self.name}, email={self.email})>"
```

### 各要素の解説

#### クラス定義
```python
class User(Base):
    """ユーザーモデル"""
    __tablename__ = "users"
```
- `User`: テーブル「users」に対応するPythonクラス
- `Base`: `database.py` で定義した `declarative_base()`を継承
- `__tablename__`: 対応するテーブル名を指定

#### カラム定義

```python
id = Column(Integer, primary_key=True, index=True)
```
| 設定 | 説明 |
|------|------|
| `Integer` | データ型が整数 |
| `primary_key=True` | プライマリキー（一意の識別子）に設定 |
| `index=True` | インデックスを作成（検索を高速化） |

```python
name = Column(String, nullable=False)
```
| 設定 | 説明 |
|------|------|
| `String` | データ型が文字列 |
| `nullable=False` | NULL（空）を許さない（必須フィールド） |

```python
email = Column(String, unique=True, nullable=False, index=True)
```
| 設定 | 説明 |
|------|------|
| `String` | データ型が文字列 |
| `unique=True` | 重複を許さない制約 |
| `nullable=False` | NULL（空）を許さない |
| `index=True` | 検索を高速化 |

```python
created_at = Column(DateTime, nullable=False, default=func.now())
```
| 設定 | 説明 |
|------|------|
| `DateTime` | データ型が日時 |
| `default=func.now()` | 登録時に自動的に現在時刻を設定 |
| `nullable=False` | NULL（空）を許さない |

#### メソッド

```python
def __repr__(self):
    """デバッグ用の表示"""
    return f"<User(id={self.id}, name={self.name}, email={self.email})>"
```
- `__repr__`: Pythonのデバッグ時に見やすい表示を提供
- 例：`print(user)` 実行時に `<User(id=1, name=山田太郎, email=yamada@example.com)>` と表示

---

## Step 3: schemas.py 作成（Pydantic スキーマ定義）

### 作成ファイル名
`schemas.py`

### 役割
FastAPI のリクエスト・レスポンス バリデーションを定義します。

### 実装コード

```python
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

class UserCreate(BaseModel):
    """ユーザー作成時のリクエストボディ"""
    name: str
    email: EmailStr  # メール形式バリデーション付き

    class Config:
        json_schema_extra = {
            "example": {
                "name": "山田太郎",
                "email": "yamada@example.com"
            }
        }


class UserUpdate(BaseModel):
    """ユーザー更新時のリクエストボディ"""
    name: Optional[str] = None
    email: Optional[EmailStr] = None

    class Config:
        json_schema_extra = {
            "example": {
                "name": "山田次郎",
                "email": "yamada.jiro@example.com"
            }
        }


class UserResponse(BaseModel):
    """ユーザー取得時のレスポンス"""
    id: int
    name: str
    email: str
    created_at: datetime

    class Config:
        from_attributes = True  # SQLAlchemyモデルを変換可能にする
        json_schema_extra = {
            "example": {
                "id": 1,
                "name": "山田太郎",
                "email": "yamada@example.com",
                "created_at": "2025-11-05T12:34:56"
            }
        }
```

### 各スキーマの役割と説明

#### UserCreate（リクエスト用）

```python
class UserCreate(BaseModel):
    name: str
    email: EmailStr
```

**使用場面:** `POST /users` でユーザー作成時

**バリデーション:**
```
name: str
└─ 文字列であること

email: EmailStr
└─ 有効なメール形式であること
   例：✅ yamada@example.com
      ❌ yamada  （メール形式ではない）
      ❌ yamada@  （不完全）
```

**リクエスト例：**
```json
{
  "name": "山田太郎",
  "email": "yamada@example.com"
}
```

#### UserUpdate（リクエスト用）

```python
class UserUpdate(BaseModel):
    name: Optional[str] = None
    email: Optional[EmailStr] = None
```

**使用場面:** `PUT /users/{id}` でユーザー更新時

**特徴:** 両フィールドが `Optional`（任意）
- `name` のみ更新：可能
- `email` のみ更新：可能
- 両方更新：可能
- 両方省略：エラー（最低1つは必須）

**リクエスト例：**
```json
{
  "name": "山田次郎"
}
```

#### UserResponse（レスポンス用）

```python
class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    created_at: datetime

    class Config:
        from_attributes = True
```

**使用場面:** エンドポイントのレスポンスとして返す

**from_attributes = True の重要性:**

```python
# データベースから取得した User オブジェクト
user = db.query(User).first()

# from_attributes = True がないと：
response = UserResponse(name=user.name, email=user.email, ...)  # 手動で変換が必要

# from_attributes = True があれば：
response = UserResponse.from_orm(user)  # SQLAlchemyモデルを自動変換
```

**レスポンス例：**
```json
{
  "id": 1,
  "name": "山田太郎",
  "email": "yamada@example.com",
  "created_at": "2025-11-05T12:34:56.000000"
}
```

### EmailStr のインストール

Pydantic v2では `EmailStr` を使うために追加パッケージが必要です：

```bash
pip install pydantic[email]
```

または、`requirements.txt` に追加：
```txt
pydantic[email]
```

---

## Step 4: テーブル自動生成

### 目的
Pythonで定義したモデルを実際のPostgreSQLテーブルに変換します。

### 実装方法

#### 方法1: main.py で実装（簡易方法・開発用）

```python
from fastapi import FastAPI
from database import engine, Base
from models import User  # モデルをインポート

# アプリケーション起動時にテーブルを自動生成
Base.metadata.create_all(bind=engine)

app = FastAPI()
# ... 以下省略
```

**動作:**
1. `docker-compose up --build` 実行
2. FastAPI起動時に `create_all()` が実行
3. `users` テーブルが自動生成される

**確認方法:**
```bash
# PostgreSQLコンテナに接続
docker-compose exec db psql -U postgres -d fastapi_db

# テーブル確認
\dt

# スキーマ確認
\d users
```

#### 方法2: Alembic を使用（本番環境向け・応用）

```python
# alembic init alembic
# alembic revision --autogenerate -m "Create users table"
# alembic upgrade head
```

※ フェーズ2では方法1を推奨。方法2は後のステップで学習可能。

---

## Step 5: 動作確認

### チェックリスト

- [ ] `models.py` を作成（上記コード参考）
- [ ] `schemas.py` を作成（上記コード参考）
- [ ] `main.py` に `Base.metadata.create_all(bind=engine)` を追加
- [ ] `Dockerfile` が `models.py` と `schemas.py` をコピーしているか確認
- [ ] `docker-compose down && docker-compose up --build` 実行
- [ ] FastAPI起動ログに「Application startup complete」が表示されるか確認

### テーブル確認手順

```bash
# PostgreSQLコンテナに接続
docker-compose exec db psql -U postgres -d fastapi_db

# テーブル一覧表示
\dt

# users テーブルの詳細確認
\d users
```

**期待される出力：**
```
                    Table "public.users"
  Column   |            Type             | Collation | Nullable | Default
-----------+-----------------------------+-----------+----------+---------
 id        | integer                     |           | not null |
 name      | character varying           |           | not null |
 email     | character varying           |           | not null |
 created_at| timestamp without time zone |           | not null | now()

Indexes:
    "users_pkey" PRIMARY KEY, btree (id)
    "ix_users_email" UNIQUE, btree (email)
    "ix_users_id" btree (id)
```

---

## よくあるエラーと対応

### エラー1: "No such table: users"

**原因:** `Base.metadata.create_all()` を実行していない

**解決:**
```python
# main.py に以下を追加
from database import engine, Base
from models import User

Base.metadata.create_all(bind=engine)
```

### エラー2: "ModuleNotFoundError: No module named 'models'"

**原因:**
- `models.py` が作成されていない
- Dockerfile が `models.py` をコピーしていない

**解決:**
1. `models.py` を作成
2. Dockerfile に `COPY models.py .` を追加
3. `docker-compose up --build` 再実行

### エラー3: "cannot import name 'EmailStr'"

**原因:** `pydantic[email]` がインストールされていない

**解決:**
```txt
# requirements.txt に追加
pydantic[email]
```

```bash
# または直接インストール
pip install pydantic[email]
```

---

## ファイル構成確認

フェーズ2完了時の構成：

```
practice-fastapi/
├── Dockerfile
├── compose.yml
├── requirements.txt
├── main.py                    ← Base.metadata.create_all() 追加
├── database.py                （変更なし）
├── models.py                  ← 新規作成
├── schemas.py                 ← 新規作成
├── .gitignore
├── 学習メモ.md
├── カリキュラム_DB連携.md
├── 学習メモ_フェーズ1完了.md
└── カリキュラム_フェーズ2_データモデル設計.md
```

---

## 次のステップ（フェーズ3の予告）

フェーズ3では以下を実装します：

- POST /users：ユーザー作成
- GET /users：全ユーザー取得
- GET /users/{id}：特定ユーザー取得
- PUT /users/{id}：ユーザー更新
- DELETE /users/{id}：ユーザー削除

各エンドポイントで以下を実装：
- パラメータバリデーション
- エラーハンドリング（404, 409 Conflict など）
- トランザクション処理

---

## 学習のコツ

✅ **小さく試す**
- 最初は CREATE だけ実装
- 動作確認してから UPDATE, DELETE を追加

✅ **ログを活用**
- `docker-compose logs fastapi` でエラー確認
- `print()` デバッグで値を追跡

✅ **ドキュメント参照**
- SQLAlchemy 公式: https://docs.sqlalchemy.org/
- Pydantic 公式: https://docs.pydantic.dev/

✅ **PostgreSQL確認**
- `psql` でテーブル構造を視認
- 実際のDB状態を把握

---

## 推奨スケジュール

**Day 1（今日の続き・初期）:**
- Step 1-4: モデル設計～テーブル自動生成
- 合計時間: 30-45分

**Day 2（明日・本日後）:**
- Step 5: 動作確認
- トラブルシューティング
- フェーズ3準備

---

明日スムーズに再開できるよう、以下をチェックリストに：

- [ ] 学習メモを読み返す
- [ ] モデル設計図を理解する
- [ ] models.py / schemas.py のテンプレートを確認
- [ ] Step 1-4 のコード説明を把握

頑張ってください！
