# FastAPI × PostgreSQL フェーズ4 認証・認可実装 カリキュラム

## フェーズ4の目標

✅ パスワード認証機能の実装（ハッシング・ソルト）
✅ JWT（JSON Web Token）トークン認証
✅ ロールベースアクセス制御（RBAC）
✅ セキュアなエンドポイント設計
✅ ユーザーの暗号化・保護

---

## 学習内容の流れ

```
フェーズ3完了（CRUD エンドポイント実装）
        ↓
フェーズ4 ← 今ここ
├─ Step 0: データモデル拡張（User テーブルにロール・パスワード追加）
├─ Step 1: スキーマ拡張（認証関連フィールド）
├─ Step 2: パスワード暗号化実装（bcrypt）
├─ Step 3: JWT トークン生成・検証機能
├─ Step 4: 認証ミドルウェア実装
├─ Step 5: 認可エンドポイント設計（ログイン）
├─ Step 6: 保護されたエンドポイント実装
└─ Step 7: 動作確認・テスト
        ↓
フェーズ5: 高度なDB操作（リレーション・検索・ページング）
```

---

## はじめに：セキュリティの重要性

### なぜ認証が必要か？

**シナリオ1: 認証なしの場合**
```
ユーザーA が GET /users/2 リクエスト
  ↓
ユーザーB のデータがそのまま返される（危険！）
```

**シナリオ2: 認証ありの場合**
```
ユーザーA が GET /users/2 リクエスト（トークン付き）
  ↓
トークンから「ユーザーA」と判定
  ↓
「アクセス権限なし」エラー返却（安全！）
```

### フェーズ4で学ぶコンセプト

| コンセプト | 説明 | 例 |
|----------|------|-----|
| **認証（Authentication）** | ユーザーが本人であることを確認 | ログイン時にパスワード検証 |
| **認可（Authorization）** | 認証済みユーザーが何ができるかを制御 | 管理者ロール→全ユーザー削除可能 |
| **ハッシング** | パスワードを暗号化（復号不可） | `password123` → `$2b$12$...` |
| **JWT トークン** | リクエストヘッダに含めるトークン | `Authorization: Bearer eyJ...` |
| **ロール（Role）** | ユーザーの権限レベル | admin, user, guest |

---

## Step 0: データモデル拡張

### 目的

User テーブルにセキュリティ関連フィールドを追加します。

### 拡張フィールド一覧

| フィールド | 型 | 説明 | 例 |
|-----------|-----|------|-----|
| `hashed_password` | VARCHAR | ハッシング化されたパスワード | `$2b$12$...` |
| `role` | VARCHAR | ユーザーのロール | `admin`, `user` |
| `is_active` | BOOLEAN | ユーザーの有効/無効 | `True` / `False` |
| `created_at` | TIMESTAMP | 作成日時 | （既存） |

### models.py の修正

**修正前（フェーズ3）:**
```python
from sqlalchemy import Column, Integer, String, DateTime
from database import Base
from datetime import datetime

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
```

**修正後（フェーズ4）:**
```python
from sqlalchemy import Column, Integer, String, DateTime, Boolean
from database import Base
from datetime import datetime

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(100), nullable=False)
    email = Column(String(100), unique=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)  # ← 新規
    role = Column(String(20), default="user")               # ← 新規（admin, user）
    is_active = Column(Boolean, default=True)               # ← 新規
    created_at = Column(DateTime, default=datetime.utcnow)
```

### マイグレーション（既存データベースの更新）

既存テーブルにカラムを追加する場合：

**方法1: テーブルリセット（開発環境のみ）**
```bash
docker-compose exec db psql -U postgres -d fastapi_db
# psql> DROP TABLE users;
# psql> \q
docker-compose restart fastapi
```

**方法2: ALTER TABLE（本番環境向け）**
```bash
docker-compose exec db psql -U postgres -d fastapi_db
# psql> ALTER TABLE users ADD COLUMN hashed_password VARCHAR(255) NOT NULL DEFAULT '';
# psql> ALTER TABLE users ADD COLUMN role VARCHAR(20) DEFAULT 'user';
# psql> ALTER TABLE users ADD COLUMN is_active BOOLEAN DEFAULT true;
# psql> \q
```

---

## Step 1: スキーマ拡張

### 目的

Pydantic スキーマにセキュリティ関連フィールドを追加します。

### schemas.py の修正

**修正後:**
```python
from pydantic import BaseModel, EmailStr, Field
from datetime import datetime
from typing import Optional

# ========== ユーザー作成時スキーマ ==========
class UserCreate(BaseModel):
    """ユーザー作成リクエスト"""
    name: str = Field(..., min_length=1, max_length=100, description="ユーザー名")
    email: EmailStr = Field(..., description="メールアドレス")
    password: str = Field(..., min_length=8, description="パスワード（8文字以上）")
    # role はデフォルト "user" に自動設定

# ========== ユーザー更新時スキーマ ==========
class UserUpdate(BaseModel):
    """ユーザー更新リクエスト（すべて Optional）"""
    name: Optional[str] = Field(None, max_length=100)
    email: Optional[EmailStr] = None
    password: Optional[str] = Field(None, min_length=8)  # 注：パスワード変更時のみ
    role: Optional[str] = None  # 注：管理者のみ変更可能

# ========== ユーザーレスポンススキーマ ==========
class UserResponse(BaseModel):
    """ユーザー取得時レスポンス（パスワードは含めない！）"""
    id: int
    name: str
    email: str
    role: str
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True  # SQLAlchemy ORM オブジェクト対応

# ========== ログインリクエストスキーマ ==========
class LoginRequest(BaseModel):
    """ログインリクエスト"""
    email: EmailStr = Field(..., description="メールアドレス")
    password: str = Field(..., description="パスワード")

# ========== トークンレスポンススキーマ ==========
class TokenResponse(BaseModel):
    """ログイン成功時レスポンス"""
    access_token: str
    token_type: str = "bearer"
    user: UserResponse

# ========== トークンペイロード（内部用） ==========
class TokenPayload(BaseModel):
    """JWT トークン内部ペイロード"""
    user_id: int
    email: str
    role: str
    exp: int  # 有効期限（Unix Timestamp）
```

### スキーマ拡張のポイント

| 項目 | 説明 |
|------|------|
| `UserCreate.password` | 作成時に必須。パスワード強度検証（8文字以上） |
| `UserResponse` | **hashed_password を含めない**（セキュリティ） |
| `LoginRequest` | ログイン用の簡単なスキーマ |
| `TokenResponse` | トークンとユーザー情報を返す |
| `TokenPayload` | JWT ペイロードの内部表現 |

---

## Step 2: パスワード暗号化実装

### 目的

パスワードを安全にハッシング・検証する機能を実装します。

### requirements.txt への追加

```bash
pip install bcrypt passlib python-jose python-multipart
```

**requirements.txt:**
```
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
pydantic==2.4.2
pydantic[email]==2.4.2
bcrypt==4.1.1          # ← 新規：パスワードハッシング
passlib==1.7.4         # ← 新規：パスワードコンテキスト（bcryptのラッパー）
python-jose==3.3.0     # ← 新規：JWT 生成
python-multipart==0.0.6 # ← 新規：フォームデータ処理
```

### パスワードハッシング実装

**新規ファイル: security.py**

```python
# security.py
from passlib.context import CryptContext
from datetime import datetime, timedelta, timezone
from typing import Optional, Annotated
from jose import JWTError, jwt
from fastapi import Depends, HTTPException, status, Header
from sqlalchemy.orm import Session
from schemas import TokenPayload
from database import get_db
from models import User

# ========== パスワード暗号化設定 ==========
pwd_context = CryptContext(
    schemes=["bcrypt"],           # bcrypt を使用
    deprecated="auto"
)

# ========== JWT 設定 ==========
SECRET_KEY = "your-secret-key-change-in-production"  # ⚠️ 本番環境では環境変数から
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60  # トークン有効期限：60分

# ========== パスワード関連関数 ==========
def hash_password(password: str) -> str:
    """平文のパスワードをハッシング

    Args:
        password: 平文パスワード

    Returns:
        ハッシング化されたパスワード

    例:
        >>> hash_password("password123")
        '$2b$12$...'
    """
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """平文パスワードがハッシュと一致するか検証

    Args:
        plain_password: 平文パスワード
        hashed_password: ハッシング化されたパスワード

    Returns:
        bool: 一致すれば True、不一致なら False

    例:
        >>> hash_pw = hash_password("password123")
        >>> verify_password("password123", hash_pw)
        True
        >>> verify_password("wrong", hash_pw)
        False
    """
    return pwd_context.verify(plain_password, hashed_password)


# ========== JWT 関連関数 ==========
def create_access_token(
    user_id: int,
    email: str,
    role: str,
    expires_delta: Optional[timedelta] = None
) -> str:
    """JWT トークンを生成

    Args:
        user_id: ユーザーID
        email: メールアドレス
        role: ロール（admin, user）
        expires_delta: トークン有効期限（デフォルト: 60分）

    Returns:
        JWT トークン文字列

    例:
        >>> token = create_access_token(user_id=1, email="user@example.com", role="user")
        >>> # トークンは以下の形式: eyJ...（JWT）
    """
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)

    payload = {
        "user_id": user_id,
        "email": email,
        "role": role,
        "exp": int(expire.timestamp())  # Unix Timestamp
    }

    encoded_jwt = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def verify_token(token: str) -> Optional[TokenPayload]:
    """JWT トークンを検証してペイロードを取得

    Args:
        token: JWT トークン文字列

    Returns:
        TokenPayload: トークンペイロード（無効なら None）

    例:
        >>> token = "eyJ..."
        >>> payload = verify_token(token)
        >>> if payload:
        ...     print(f"User ID: {payload.user_id}")
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return TokenPayload(**payload)
    except JWTError:
        return None


# ========== 認証ヘッダーからトークンを抽出 ==========
def _extract_token_from_header(authorization: str | None = Header(None)) -> str:
    """Authorization ヘッダーから Bearer トークンを抽出

    Args:
        authorization: Authorization ヘッダー（自動注入）

    Returns:
        str: トークン文字列

    Raises:
        HTTPException 401: Authorization ヘッダーがない、または形式が違う

    例:
        Authorization: Bearer eyJ...
    """
    if not authorization:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authorization ヘッダーが必要です",
            headers={"WWW-Authenticate": "Bearer"}
        )

    parts = authorization.split()
    if len(parts) != 2 or parts[0].lower() != "bearer":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="無効な Authorization ヘッダー形式です",
            headers={"WWW-Authenticate": "Bearer"}
        )

    return parts[1]
```

### セキュリティのベストプラクティス

**🔒 ハッシング vs 暗号化**

| 特性 | ハッシング | 暗号化 |
|------|-----------|-------|
| 復号可能か？ | ❌ 不可（一方向） | ✅ 可能（双方向） |
| 用途 | パスワード | データ（クレジットカード等） |
| bcrypt/Argon2 | ✅ 推奨 | ❌ 不適切 |
| 速度 | 遅い（意図的） | 速い |

**passlib とは？**

`passlib` は、bcrypt、scrypt、Argon2 などの複数のハッシングアルゴリズムを統一的に扱うライブラリです。

```python
from passlib.context import CryptContext

# CryptContext で bcrypt を設定
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# bcrypt でハッシング化
hashed = pwd_context.hash("password123")

# 平文とハッシュを比較（bcrypt の内部で自動的に処理）
is_valid = pwd_context.verify("password123", hashed)  # True
```

**なぜ passlib が必要か？**

- ✅ bcrypt を直接使うより簡単
- ✅ 複数のハッシングアルゴリズムに対応
- ✅ ハッシュの検証（ソルト抽出）を自動化
- ✅ セキュリティベストプラクティスに準拠

**パスワード処理の正しい流れ:**

```
ユーザー入力：password123
    ↓
① passlib（bcrypt） でハッシング
    ↓
② DB に保存：$2b$12$...（復号不可）
    ↓
ログイン時：
    ↓
③ 入力パスワードを passlib（bcrypt） でハッシング
    ↓
④ DB 内のハッシュと比較（復号しない）
    ↓
一致 → ログイン成功
```

---

## Step 3: JWT トークン生成・検証機能

### JWT とは？

**JWT（JSON Web Token）の構造:**

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxLCJlbWFpbCI6InVzZXJAZXhhbXBsZS5jb20iLCJyb2xlIjoidXNlciIsImV4cCI6MTcwMDA2NjAwMH0.signature
```

**3つの部分に分かれている:**

1. **Header（ヘッダー）**
   ```json
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   ```

2. **Payload（ペイロード）**
   ```json
   {
     "user_id": 1,
     "email": "user@example.com",
     "role": "user",
     "exp": 1700066000
   }
   ```

3. **Signature（署名）**
   - SECRET_KEY で署名されたハッシュ
   - 改ざん検出用

### JWT フロー図

```
ログイン画面
    ↓
POST /login にメール＆パスワード送信
    ↓
サーバー側：
  ① パスワード検証
  ② JWT トークン生成
    ↓
クライアントが JWT を受け取り
    ↓
以後のリクエストに JWT を付与
  Authorization: Bearer eyJ...
    ↓
サーバー側：
  ① JWT を検証
  ② ペイロードからユーザーID取得
  ③ アクセス権限チェック
    ↓
レスポンス返却
```

### security.py は Step 2 で実装済み

前述の `create_access_token()` と `verify_token()` を使用します。

---

## Step 4: 認証ミドルウェア実装

### 目的

リクエストヘッダから JWT トークンを取得し、ユーザーを認証します。

### FastAPI の Depends（依存性注入）

**修正後 security.py に追加:**

```python
from typing import Annotated
from fastapi import Depends, HTTPException, status, Header
from sqlalchemy.orm import Session
from database import get_db
from models import User

# ========== 現在のユーザーを取得する依存性関数 ==========
def get_current_user(
    token: Annotated[str, Depends(_extract_token_from_header)],
    db: Session = Depends(get_db)
) -> User:
    """リクエストから現在のユーザーを取得

    Args:
        token: JWT トークン（Authorization ヘッダーから自動抽出）
        db: データベースセッション

    Returns:
        User: 認証済みユーザーオブジェクト

    Raises:
        HTTPException 401: トークンが無効または期限切れ

    例:
        @router.get("/profile")
        def get_profile(user: User = Depends(get_current_user)):
            return user
    """
    # トークンを検証
    payload = verify_token(token)
    if not payload:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="無効なトークンです",
            headers={"WWW-Authenticate": "Bearer"}
        )

    # ユーザーを DB から取得
    user = db.query(User).filter(User.id == payload.user_id).first()
    if not user or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="ユーザーが見つかりません",
            headers={"WWW-Authenticate": "Bearer"}
        )

    return user


def get_current_admin(
    current_user: User = Depends(get_current_user)
) -> User:
    """現在のユーザーが admin ロールであることを確認

    Args:
        current_user: 認証済みユーザー

    Returns:
        User: admin ロールのユーザー

    Raises:
        HTTPException 403: admin ロールではない

    例:
        @router.delete("/users/{user_id}")
        def delete_user(user_id: int, admin: User = Depends(get_current_admin)):
            # このエンドポイントは admin のみアクセス可能
    """
    if current_user.role != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="このオペレーションは管理者のみ実行可能です"
        )
    return current_user
```

### 認証ミドルウェアの流れ

```
リクエスト受信
    ↓
Authorization: Bearer eyJ... をチェック
    ↓
トークンがない → 401 Unauthorized エラー
    ↓
トークンを verify_token() で検証
    ↓
トークンが無効 → 401 Unauthorized エラー
    ↓
トークンから user_id を取得
    ↓
DB から User を取得
    ↓
User.is_active == False → 401 エラー
    ↓
✅ ユーザーを関数に渡す
```

---

## Step 5: 認可エンドポイント設計（ログイン）

### 目的

メール＆パスワード認証でトークンを発行するログインエンドポイントを実装します。

### POST /login エンドポイント

**routers/users.py に追加:**

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from database import get_db
from models import User
from schemas import LoginRequest, TokenResponse, UserCreate, UserResponse, UserUpdate
from security import hash_password, verify_password, create_access_token, get_current_user, get_current_admin

router = APIRouter(prefix="/users", tags=["users"])

# ========== ログインエンドポイント ==========
@router.post("/login", response_model=TokenResponse, status_code=status.HTTP_200_OK)
def login(
    login_request: LoginRequest,
    db: Session = Depends(get_db)
):
    """ユーザーログインエンドポイント（認証）

    Args:
        login_request: メールアドレスとパスワード
        db: データベースセッション

    Returns:
        TokenResponse: JWT トークンとユーザー情報

    Raises:
        HTTPException 401: メールアドレスまたはパスワードが間違っている

    リクエスト例:
        POST /users/login
        Content-Type: application/json

        {
          "email": "user@example.com",
          "password": "password123"
        }

    成功レスポンス（200 OK）:
        {
          "access_token": "eyJ...",
          "token_type": "bearer",
          "user": {
            "id": 1,
            "name": "山田太郎",
            "email": "yamada@example.com",
            "role": "user",
            "is_active": true,
            "created_at": "2025-11-06T12:00:00"
          }
        }
    """
    # メールアドレスで ユーザー検索
    user = db.query(User).filter(User.email == login_request.email).first()

    # ユーザーが存在しない、またはパスワード不一致
    if not user or not verify_password(login_request.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="メールアドレスまたはパスワードが間違っています",
            headers={"WWW-Authenticate": "Bearer"}
        )

    # ユーザーが無効化されている
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="このユーザーアカウントは無効化されています"
        )

    # JWT トークンを生成
    access_token = create_access_token(
        user_id=user.id,
        email=user.email,
        role=user.role
    )

    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user": user
    }
```

### セキュリティベストプラクティス

**❌ 危険な実装:**
```python
# 間違い: 詳細なエラーメッセージ
if not user:
    raise HTTPException(detail="ユーザーが見つかりません")  # ユーザー存在有無を漏らしている
if not verify_password(...):
    raise HTTPException(detail="パスワードが間違っています")  # パスワードが存在を漏らしている
```

**✅ 安全な実装:**
```python
# 正解: 同じエラーメッセージを返す
if not user or not verify_password(...):
    raise HTTPException(detail="メールアドレスまたはパスワードが間違っています")
    # どちらが間違いかわからない → セキュアな設計
```

---

## Step 6: 保護されたエンドポイント実装

### 目的

認証が必要なエンドポイントに `get_current_user` または `get_current_admin` を追加します。

### ユーザー作成エンドポイントの修正

フェーズ3では誰でもユーザー作成できました。フェーズ4では変更します：

**修正後 routers/users.py:**

```python
# ========== ユーザー作成（新規ユーザー登録） ==========
@router.post("", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def create_user(
    user: UserCreate,
    db: Session = Depends(get_db)
):
    """新規ユーザー登録エンドポイント（認証不要）

    このエンドポイントは誰でもアクセス可能（認証不要）
    新規ユーザー登録用

    Args:
        user: ユーザー作成スキーマ（name, email, password）
        db: データベースセッション

    Returns:
        UserResponse: 作成されたユーザー情報

    Raises:
        HTTPException 409: メールアドレスが既に登録されている
    """
    try:
        # パスワードをハッシング
        hashed_password = hash_password(user.password)

        # 新規 User オブジェクト作成
        db_user = User(
            name=user.name,
            email=user.email,
            hashed_password=hashed_password,
            role="user"  # 新規ユーザーはデフォルト "user" ロール
        )

        db.add(db_user)
        db.commit()
        db.refresh(db_user)

        return db_user

    except IntegrityError:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="メールアドレスは既に登録されています"
        )
```

### 認証が必要なエンドポイント

```python
# ========== 自分のプロフィール取得 ==========
@router.get("/me", response_model=UserResponse)
def get_my_profile(
    current_user: User = Depends(get_current_user)
):
    """認証済みユーザーの自分のプロフィール取得

    Args:
        current_user: 認証済みユーザー（自動注入）

    Returns:
        UserResponse: ユーザー情報

    使用例:
        GET /users/me
        Authorization: Bearer eyJ...
    """
    return current_user


# ========== 全ユーザー取得（管理者のみ） ==========
@router.get("", response_model=list[UserResponse])
def read_users(
    admin: User = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """全ユーザー取得（admin ロールのみ）

    Args:
        admin: admin ロールの認証済みユーザー
        db: データベースセッション

    Returns:
        list[UserResponse]: 全ユーザーのリスト

    注意:
        admin ロールのトークンが必須
        user ロールでリクエストした場合は 403 Forbidden エラー
    """
    users = db.query(User).all()
    return users


# ========== 特定ユーザー取得 ==========
@router.get("/{user_id}", response_model=UserResponse)
def read_user(
    user_id: int,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """特定ユーザー取得（認証必須、ユーザー本人またはadmin）

    Args:
        user_id: ユーザーID
        current_user: 認証済みユーザー
        db: データベースセッション

    Returns:
        UserResponse: ユーザー情報

    アクセス制御:
        - user ロール：自分のプロフィールのみ取得可能
        - admin ロール：全ユーザー取得可能

    Raises:
        HTTPException 403: アクセス権限なし
        HTTPException 404: ユーザーが見つからない
    """
    # ユーザーを DB から取得
    db_user = db.query(User).filter(User.id == user_id).first()

    if not db_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ユーザーが見つかりません"
        )

    # 権限チェック：user ロールは自分のみ、admin ロールは全員
    if current_user.role != "admin" and current_user.id != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="このユーザーのプロフィールを表示する権限がありません"
        )

    return db_user


# ========== ユーザー更新 ==========
@router.put("/{user_id}", response_model=UserResponse)
def update_user(
    user_id: int,
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """ユーザー更新（認証必須、ユーザー本人またはadmin）

    Args:
        user_id: ユーザーID
        user_update: 更新内容（name, email, password, role）
        current_user: 認証済みユーザー
        db: データベースセッション

    Returns:
        UserResponse: 更新されたユーザー情報

    制限事項:
        - user ロール：自分の name, email, password のみ変更可能
        - admin ロール：全フィールド変更可能

    Raises:
        HTTPException 403: 権限なし
        HTTPException 404: ユーザーが見つからない
        HTTPException 409: メール重複
    """
    # 対象ユーザーを取得
    db_user = db.query(User).filter(User.id == user_id).first()

    if not db_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ユーザーが見つかりません"
        )

    # 権限チェック：user ロールは自分のみ、admin ロールは全員
    if current_user.role != "admin" and current_user.id != user_id:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="このユーザーを編集する権限がありません"
        )

    # user ロールは role フィールドを変更できない
    if current_user.role != "admin" and user_update.role is not None:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="ロール変更は管理者のみ可能です"
        )

    try:
        # 更新フィールドを反映
        if user_update.name is not None:
            db_user.name = user_update.name

        if user_update.email is not None:
            db_user.email = user_update.email

        if user_update.password is not None:
            db_user.hashed_password = hash_password(user_update.password)

        # admin のみロール変更可能
        if user_update.role is not None and current_user.role == "admin":
            db_user.role = user_update.role

        db.commit()
        db.refresh(db_user)

        return db_user

    except IntegrityError:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="メールアドレスは既に登録されています"
        )


# ========== ユーザー削除（管理者のみ） ==========
@router.delete("/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(
    user_id: int,
    admin: User = Depends(get_current_admin),
    db: Session = Depends(get_db)
):
    """ユーザー削除（admin ロールのみ）

    Args:
        user_id: ユーザーID
        admin: admin ロールの認証済みユーザー
        db: データベースセッション

    Raises:
        HTTPException 403: admin ロールではない
        HTTPException 404: ユーザーが見つからない

    注意:
        自分自身は削除できない
    """
    # 自分自身の削除を防ぐ
    if admin.id == user_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="自分自身を削除することはできません"
        )

    # 対象ユーザーを取得
    db_user = db.query(User).filter(User.id == user_id).first()

    if not db_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ユーザーが見つかりません"
        )

    # 削除
    db.delete(db_user)
    db.commit()
```

---

## Step 7: 動作確認・テスト

### チェックリスト

- [ ] `requirements.txt` に bcrypt, passlib, python-jose, python-multipart を追加
- [ ] `models.py` に hashed_password, role, is_active カラムを追加
- [ ] `schemas.py` に UserCreate.password を追加
- [ ] 新規ファイル `security.py` を作成
- [ ] `routers/users.py` を修正（5つのエンドポイント + ログイン）
- [ ] `main.py` にセキュリティ設定を追加（必要に応じて）
- [ ] DB マイグレーション実行
- [ ] `docker-compose up --build` で起動
- [ ] テストユーザー（user ロール）を作成
- [ ] テスト管理者（admin ロール）を DB に直接挿入
- [ ] テストを実行

### Swagger UI での動作確認

#### 1. 新規ユーザー登録（POST /users）

```bash
リクエスト:
  POST http://localhost:8000/users
  Content-Type: application/json

  {
    "name": "山田太郎",
    "email": "yamada@example.com",
    "password": "password123"
  }

期待される結果: 201 Created
  {
    "id": 1,
    "name": "山田太郎",
    "email": "yamada@example.com",
    "role": "user",
    "is_active": true,
    "created_at": "2025-11-06T12:00:00"
  }
```

#### 2. ユーザーログイン（POST /users/login）

```bash
リクエスト:
  POST http://localhost:8000/users/login
  Content-Type: application/json

  {
    "email": "yamada@example.com",
    "password": "password123"
  }

期待される結果: 200 OK
  {
    "access_token": "eyJ...",
    "token_type": "bearer",
    "user": {
      "id": 1,
      "name": "山田太郎",
      "email": "yamada@example.com",
      "role": "user",
      "is_active": true,
      "created_at": "2025-11-06T12:00:00"
    }
  }
```

#### 3. パスワード間違い（POST /users/login）

```bash
リクエスト:
  POST http://localhost:8000/users/login
  Content-Type: application/json

  {
    "email": "yamada@example.com",
    "password": "wrong-password"  # ❌ 間違い
  }

期待される結果: 401 Unauthorized
  {
    "detail": "メールアドレスまたはパスワードが間違っています"
  }
```

#### 4. 自分のプロフィール取得（GET /users/me）

```bash
リクエスト:
  GET http://localhost:8000/users/me
  Authorization: Bearer eyJ...

期待される結果: 200 OK
  {
    "id": 1,
    "name": "山田太郎",
    "email": "yamada@example.com",
    "role": "user",
    "is_active": true,
    "created_at": "2025-11-06T12:00:00"
  }
```

#### 5. トークンなしでアクセス（GET /users/me）

```bash
リクエスト:
  GET http://localhost:8000/users/me
  # Authorization ヘッダーなし

期待される結果: 401 Unauthorized
  {
    "detail": "無効なトークンです"
  }
```

#### 6. 無効なトークンでアクセス（GET /users/me）

```bash
リクエスト:
  GET http://localhost:8000/users/me
  Authorization: Bearer invalid-token-xyz

期待される結果: 401 Unauthorized
  {
    "detail": "無効なトークンです"
  }
```

#### 7. 他ユーザーのプロフィール取得（GET /users/{id}）

```bash
# ユーザーA のトークンでユーザーB のプロフィールを取得しようとする

リクエスト:
  GET http://localhost:8000/users/2
  Authorization: Bearer {ユーザーA のトークン}

期待される結果: 403 Forbidden
  {
    "detail": "このユーザーのプロフィールを表示する権限がありません"
  }
```

#### 7-1. admin ロールユーザーの作成方法（推奨フロー）

**注意:** 通常のエンドポイントではユーザーは自動的に `role: "user"` で作成されます。
admin ロールを設定するには、以下のフロー（方法1 + 方法2の組み合わせ）を使用してください：

---

### 推奨フロー: 通常ユーザー作成 → admin 昇格 → admin トークンで新規ユーザー作成

**ステップ1: 通常ユーザー「山田太郎」を作成**

```bash
POST http://localhost:8000/users
Content-Type: application/json

{
  "name": "山田太郎",
  "email": "yamada@example.com",
  "password": "password123"
}
```

期待される結果（201 Created）:
```json
{
  "id": 1,
  "name": "山田太郎",
  "email": "yamada@example.com",
  "role": "user",
  "is_active": true,
  "created_at": "2025-11-06T12:00:00"
}
```

**ステップ2: DB コマンドで山田太郎を admin に昇格**

```bash
docker-compose exec db psql -U postgres -d fastapi_db

# psql>
UPDATE users SET role = 'admin' WHERE email = 'yamada@example.com';

# 確認（確認コマンド）
SELECT id, name, email, role FROM users;

# 期待される結果:
#  id |  name   |      email       | role
# ----+---------+------------------+-------
#   1 | 山田太郎 | yamada@example.com | admin

# psql を終了
\q
```

**ステップ3: 山田太郎（admin）でログイン**

```bash
POST http://localhost:8000/users/login
Content-Type: application/json

{
  "email": "yamada@example.com",
  "password": "password123"
}
```

期待される結果（200 OK）:
```json
{
  "access_token": "eyJ...",
  "token_type": "bearer",
  "user": {
    "id": 1,
    "name": "山田太郎",
    "email": "yamada@example.com",
    "role": "admin",
    "is_active": true,
    "created_at": "2025-11-06T12:00:00"
  }
}
```

**ステップ4: admin トークンで新規ユーザー「田中花子」を作成**

```bash
POST http://localhost:8000/users/admin/create
Authorization: Bearer {ステップ3で取得したトークン}
Content-Type: application/json

{
  "name": "田中花子",
  "email": "tanaka@example.com",
  "password": "password456"
}
```

期待される結果（201 Created）:
```json
{
  "id": 2,
  "name": "田中花子",
  "email": "tanaka@example.com",
  "role": "user",
  "is_active": true,
  "created_at": "2025-11-06T12:10:00"
}
```

---

### 別方法：DB に直接 admin ユーザーを挿入（初回セットアップ用のみ）

初回セットアップで既に admin ユーザーが必要な場合は、以下の方法を使用：

```bash
docker-compose exec db psql -U postgres -d fastapi_db

# psql>
INSERT INTO users (name, email, hashed_password, role, is_active, created_at)
VALUES ('山田太郎', 'yamada@example.com', '$2b$12$...', 'admin', true, NOW());

# コピーしたハッシュ値 ($2b$12$...) の代わりに、
# 別途 bcrypt でハッシングしたパスワードを使用してください。

# psql を終了
\q
```

**bcrypt ハッシュの生成方法:**

```python
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
hashed = pwd_context.hash("password123")
print(hashed)
# 出力例: $2b$12$N9qo8uLOickgx2ZMRZoMyeIjZAgcg7b3XeKeUxG2K87KZgQwa7Ey2a
# （コピーして上記の SQL に使用）
```

---

#### 8. 管理者ロールで全ユーザー取得（GET /users）

**前提条件:** ステップ1〜4で以下のユーザーが作成されていること
- id=1: 山田太郎（role=admin）
- id=2: 田中花子（role=user）

```bash
# 山田太郎（admin）のトークンを使用して全ユーザー取得

リクエスト:
  GET http://localhost:8000/users
  Authorization: Bearer {ステップ3で取得したadminトークン}

期待される結果: 200 OK
[
  {
    "id": 1,
    "name": "山田太郎",
    "email": "yamada@example.com",
    "role": "admin",
    "is_active": true,
    "created_at": "2025-11-06T12:00:00"
  },
  {
    "id": 2,
    "name": "田中花子",
    "email": "tanaka@example.com",
    "role": "user",
    "is_active": true,
    "created_at": "2025-11-06T12:10:00"
  }
]
```

#### 9. user ロールで全ユーザー取得（GET /users）

```bash
# user ロールのユーザーで実行

リクエスト:
  GET http://localhost:8000/users
  Authorization: Bearer {user のトークン}

期待される結果: 403 Forbidden
  {
    "detail": "このオペレーションは管理者のみ実行可能です"
  }
```

### Thunder Client でのテスト

#### 1. ログイン

```
POST http://localhost:8000/users/login
Content-Type: application/json

{
  "email": "yamada@example.com",
  "password": "password123"
}
```

**応答から `access_token` の値をコピー**

#### 2. 認証付きリクエスト

```
GET http://localhost:8000/users/me
Authorization: Bearer {コピーしたトークン}
```

---

## セキュリティチェックリスト

フェーズ4完了時に確認すべき項目：

### パスワード管理

- [ ] パスワードは bcrypt でハッシング化
- [ ] ハッシング化されたパスワードが DB に保存
- [ ] ログインレスポンスに hashed_password を含めない
- [ ] パスワード検証は bcrypt.verify() を使用
- [ ] パスワード最小文字数は8文字以上

### JWT トークン

- [ ] SECRET_KEY は環境変数から読み込む（本番環境）
- [ ] トークン有効期限が設定されている（デフォルト：60分）
- [ ] トークン署名に HS256 を使用
- [ ] トークン検証エラーで 401 Unauthorized を返す

### 認可（Authorization）

- [ ] admin ロール：全エンドポイントアクセス可能
- [ ] user ロール：自分のプロフィールのみ編集可能
- [ ] 権限なしアクセスで 403 Forbidden を返す
- [ ] role フィールドは admin のみ変更可能

### エラーメッセージ

- [ ] ログイン失敗時に詳細エラーを返さない
- [ ] 「メールが存在しない」と「パスワード間違い」を区別しない
- [ ] トークン無効時に詳細を漏らさない

---

## よくあるエラーと対応

### エラー1: "ModuleNotFoundError: No module named 'passlib'"

**原因:** passlib がインストールされていない

**解決:**

requirements.txt に以下を追加してください：

```txt
passlib==1.7.4
```

その後、以下を実行します：

```bash
# ローカル環境の場合
pip install passlib

# Docker 環境の場合
docker-compose down
docker-compose up --build
```

**チェック項目:**

requirements.txt に以下の4つが記載されているか確認してください：

```txt
bcrypt==4.1.1          # パスワードハッシング
passlib==1.7.4         # パスワードコンテキスト
python-jose==3.3.0     # JWT生成
python-multipart==0.0.6 # フォームデータ処理
```

### エラー2: "IntegrityError: duplicate key value violates unique constraint"

**原因:** 同じメールアドレスで複数登録しようとした

**解決:**
```bash
# テーブルをリセット
docker-compose exec db psql -U postgres -d fastapi_db
# psql> DROP TABLE users;
# psql> \q
docker-compose restart fastapi
```

### エラー3: "HTTPException 401: 無効なトークンです"

**原因:**
- トークンが含まれていない
- トークンが改ざんされた
- トークンの有効期限切れ

**解決:**
- Authorization ヘッダーに `Bearer {token}` 形式で含める
- ログインして新しいトークンを取得

### エラー4: "HTTPException 403: このオペレーションは管理者のみ実行可能です"

**原因:** user ロールで admin 専用エンドポイントにアクセス

**解決:**
- admin ロールのトークンで再度リクエスト
- または、別の管理者に依頼

---

## ファイル構成確認（フェーズ4完了時）

```
practice-fastapi/
├── Dockerfile
├── compose.yml
├── requirements.txt                ← bcrypt 等を追加
├── main.py                         （フェーズ3と同様）
├── database.py                     （変更なし）
├── models.py                       ← hashed_password, role, is_active を追加
├── schemas.py                      ← password フィールドを追加
├── security.py                     ← 新規ファイル（認証・認可機能）
├── routers/
│   ├── __init__.py
│   └── users.py                   ← 5エンドポイント + ログイン実装
├── .gitignore
├── 学習メモ.md
├── curriculum/
│   ├── カリキュラム_フェーズ1_DB連携.md
│   ├── カリキュラム_フェーズ2_データモデル設計.md
│   ├── カリキュラム_フェーズ3_CRUD実装.md
│   └── カリキュラム_フェーズ4_認証認可実装.md      ← 本ファイル
├── studymemo/
│   ├── 学習メモ_フェーズ1完了.md
│   ├── 学習メモ_フェーズ2完了.md
│   └── 学習メモ_フェーズ3完了.md
```

### 修正ファイル一覧

| ファイル | 修正内容 |
|---------|---------|
| `requirements.txt` | bcrypt, python-jose, python-multipart を追加 |
| `models.py` | hashed_password, role, is_active カラムを追加 |
| `schemas.py` | password フィールドとトークン関連スキーマを追加 |
| `security.py` | 新規作成：認証・認可機能 |
| `routers/users.py` | ログイン機能と保護されたエンドポイント実装 |

---

## 学習のコツ

✅ **段階的にテスト**
- まず新規登録だけ動作確認
- 次にログイン機能
- 最後に保護されたエンドポイント

✅ **Swagger UI で認証テスト**
- トークンを入力フィールドにペースト可能
- Authorization ヘッダーが自動付与される

✅ **ログを活用**
```bash
docker-compose logs fastapi
```
- エラーメッセージを読む
- トークン検証の失敗ポイントを確認

✅ **セキュリティを理解する**
- なぜパスワードをハッシング化するのか
- なぜトークンに有効期限があるのか
- なぜロールベースアクセス制御が必要か

---

## 推奨スケジュール

**Day 1（フェーズ4初日）:**
- Step 0-1: データモデル・スキーマ拡張
- Step 2-3: パスワードハッシング・JWT 実装
- 合計時間: 60-90分

**Day 2（フェーズ4中日）:**
- Step 4-5: 認証ミドルウェア・ログイン実装
- 合計時間: 60分

**Day 3（フェーズ4完了日）:**
- Step 6: 保護されたエンドポイント実装
- Step 7: 動作確認・テスト
- 合計時間: 90-120分

---

## 完了の確認

フェーズ4 完了条件（すべて ✅ か確認）：

**パッケージと依存関係:**
- [ ] `requirements.txt` に bcrypt, python-jose, python-multipart を追加
- [ ] `pip install` で全パッケージインストール

**データモデル（models.py）:**
- [ ] `hashed_password` フィールド追加（VARCHAR 255）
- [ ] `role` フィールド追加（デフォルト: "user"）
- [ ] `is_active` フィールド追加（デフォルト: True）

**スキーマ（schemas.py）:**
- [ ] `UserCreate` に `password` フィールド追加
- [ ] `UserResponse` に `role`, `is_active` フィールド追加
- [ ] `UserResponse` に hashed_password を含めない
- [ ] `LoginRequest` スキーマ作成
- [ ] `TokenResponse` スキーマ作成

**セキュリティ（security.py）:**
- [ ] `hash_password()` 関数実装
- [ ] `verify_password()` 関数実装
- [ ] `create_access_token()` 関数実装
- [ ] `verify_token()` 関数実装
- [ ] `get_current_user()` 依存性関数実装
- [ ] `get_current_admin()` 依存性関数実装

**ルータ（routers/users.py）:**
- [ ] POST /users（新規ユーザー登録、パスワードハッシング）
- [ ] POST /users/login（ログイン、トークン発行）
- [ ] GET /users/me（自分のプロフィール）
- [ ] GET /users（admin のみ全ユーザー取得）
- [ ] GET /users/{id}（認証+権限チェック）
- [ ] PUT /users/{id}（認証+権限チェック）
- [ ] DELETE /users/{id}（admin のみ削除）

**動作確認:**
- [ ] `docker-compose up --build` が成功
- [ ] 新規ユーザー登録可能（201 Created）
- [ ] ログイン可能（200 OK + トークン返却）
- [ ] パスワード間違い時に 401 返却
- [ ] トークンなしで 401 返却
- [ ] 無効なトークンで 401 返却
- [ ] user ロールが admin エンドポイントにアクセスで 403 返却
- [ ] user ロールが他ユーザー編集で 403 返却
- [ ] admin ロールが全ユーザー取得可能（200 OK）
- [ ] admin ロールが全ユーザー削除可能（204 No Content）

**セキュリティ確認:**
- [ ] DB にハッシング化されたパスワードが保存されている
- [ ] ハッシング化されたパスワードをレスポンスに含めていない
- [ ] ログイン失敗時にメール存在有無を漏らしていない
- [ ] トークン有効期限が設定されている

**すべての項目が ✅ であれば、フェーズ4 完了！**

---

## 次のステップ（フェーズ5の予告）

フェーズ5では以下を実装します：

- データベースリレーション（外部キー）
- 複数テーブル間の JOIN クエリ
- ページング・フィルタリング・ソート
- 検索機能の実装
- N+1 クエリ問題の解決

---

## 参考リンク

- FastAPI セキュリティ: https://fastapi.tiangolo.com/tutorial/security/
- bcrypt ドキュメント: https://github.com/pyca/bcrypt
- JWT 解説: https://tools.ietf.org/html/rfc7519
- OWASP セキュリティ: https://owasp.org/www-project-top-ten/

---

頑張ってください！
