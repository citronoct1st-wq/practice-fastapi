# Docker + FastAPI × PostgreSQL フェーズ1 環境構築 完了メモ

## 学習成果

✅ PostgreSQLコンテナの構築
✅ SQLAlchemy ORM の初期設定完了
✅ FastAPIからのDB接続確認

---

## 実装したファイル一覧

### 1. requirements.txt - Python依存パッケージ管理

```txt
fastapi==0.104.1
uvicorn==0.24.0
python-dotenv==1.0.0

sqlalchemy==2.0.23          # ORM フレームワーク
psycopg2-binary==2.9.9      # PostgreSQL用ドライバー
alembic==1.12.1             # マイグレーションツール（オプション）
```

**追加内容の説明:**

| パッケージ | 役割 |
|-----------|------|
| `sqlalchemy==2.0.23` | Object-Relational Mapping (ORM) フレームワーク。Pythonのオブジェクトとデータベーステーブルを対応させる |
| `psycopg2-binary==2.9.9` | PostgreSQL用ドライバー。FastAPIからPostgreSQLへの接続を可能にする |
| `alembic==1.12.1` | データベーススキーマのバージョン管理ツール（マイグレーション） |

---

### 2. compose.yml - Docker環境定義

```yaml
version: '3.8'
services:
  fastapi:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - .:/app
    environment:
      - ENV=development
    depends_on:
      db:
        condition: service_healthy

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: fastapi_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
```

**重要設定の解説:**

#### FastAPIサービス
| 設定 | 説明 |
|------|------|
| `depends_on: db (condition: service_healthy)` | PostgreSQLの起動完了を待ってからFastAPIを起動 |
| `volumes: .:/app` | ホスト側の全ファイルをコンテナ内の/appに同期（開発効率向上） |

#### PostgreSQLサービス
| 設定 | 説明 |
|------|------|
| `image: postgres:15` | PostgreSQL公式イメージのバージョン15を使用 |
| `POSTGRES_USER/PASSWORD/DB` | デフォルトユーザー、パスワード、データベース名の設定 |
| `healthcheck` | PostgreSQL起動完了を検知（retries: 5回失敗したら終了） |
| `volumes: postgres_data:/var/lib/postgresql/data` | DBデータを永続化（コンテナ削除後もデータ残存） |

**ポイント: healthcheck と depends_on の組み合わせ**

```
compose up実行
  ↓
PostgreSQLコンテナ起動
  ↓
healthcheck: pg_isready コマンドで起動確認
  ↓
成功 → FastAPIコンテナ起動
  ↓
アプリケーション実行
```

これにより、データベース接続エラーを防ぐことができます。

---

### 3. Dockerfile - イメージビルド定義

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY main.py .
COPY database.py .

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**修正ポイント:**

```dockerfile
COPY main.py .
COPY database.py .
```

元のDockerfileは `main.py` のみをコピーしていましたが、`main.py` が `database.py` をimportしているため、両方のファイルをコピーする必要があります。

---

### 4. database.py - DB接続設定（新規作成）

```python
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.pool import NullPool
import os

# 環境変数からDB接続情報を取得
DB_USER = os.getenv("POSTGRES_USER", "postgres")
DB_PASSWORD = os.getenv("POSTGRES_PASSWORD", "password")
DB_HOST = os.getenv("POSTGRES_HOST", "db")  # Docker内のサービス名
DB_PORT = os.getenv("POSTGRES_PORT", "5432")
DB_NAME = os.getenv("POSTGRES_DB", "fastapi_db")

# PostgreSQL接続文字列
DATABASE_URL = f"postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}"

# SQLAlchemy エンジン作成
engine = create_engine(DATABASE_URL, poolclass=NullPool)

# セッション作成用の関数
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# ORM モデルの基底クラス
Base = declarative_base()

# FastAPIで使用する依存性注入用関数
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

**各要素の説明:**

#### エンジン（engine）
```python
engine = create_engine(DATABASE_URL, poolclass=NullPool)
```
- PostgreSQLとの接続を管理する中核オブジェクト
- `poolclass=NullPool`: コネクションプーリングなし（Dockerの軽量開発環境用）

#### セッション（SessionLocal）
```python
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
```
- データベーストランザクションを管理
- `autocommit=False`: 明示的にcommitしない限り自動反映しない
- `autoflush=False`: 明示的にflushしない限り自動送信しない

#### 基底クラス（Base）
```python
Base = declarative_base()
```
- SQLAlchemy ORM モデル定義の親クラス
- 後で作成するテーブルモデルはこれを継承

#### 依存性注入関数（get_db）
```python
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```
- FastAPIのDependencyで使用
- 例: `def create_user(db: Session = Depends(get_db))`
- 自動的にセッション作成・クローズを管理

---

### 5. main.py - FastAPIアプリケーション修正

```python
from fastapi import FastAPI
from database import SessionLocal
from sqlalchemy import text

app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello, Docker + FastAPI!"}

@app.get("/items/{item_id}")
def read_item(item_id: int, q: str = None):
    return {"item_id": item_id, "q": q}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


@app.on_event("startup")
def startup():
    db = SessionLocal()
    try:
        db.execute(text("SELECT 1"))
        print("✓ Database connected successfully!")
    finally:
        db.close()
```

**修正内容:**

| 修正項目 | 説明 |
|---------|------|
| `from database import SessionLocal` | データベース接続設定をインポート |
| `from sqlalchemy import text` | SQLAlchemy 2.0対応：文字列SQLをtext()でラップ |
| `@app.on_event("startup")` | サーバー起動時に実行するハンドラー |
| `db.execute(text("SELECT 1"))` | DB接続確認クエリ実行 |

**SQLAlchemy 2.0 での注意点:**

SQLAlchemy 2.0では、文字列SQLを直接実行できません。

```python
# ❌ エラー（SQLAlchemy 2.0以降）
db.execute("SELECT 1")

# ✅ 正しい方法
from sqlalchemy import text
db.execute(text("SELECT 1"))
```

---

### 6. .gitignore - Git除外設定

重要な設定項目：

```gitignore
# Environment variables
.env
.env.local

# PostgreSQL Docker data
postgres_data/
```

機密情報やローカルDBデータをgitにコミットしないようにします。

---

## 動作確認コマンド

### ビルド・起動
```bash
docker-compose down
docker-compose up --build
```

### ログ確認
```bash
docker-compose logs fastapi
docker-compose logs db
```

### 成功時のログ
```
fastapi-1  | ✓ Database connected successfully!
fastapi-1  | INFO:     Application startup complete
db        | LOG:  database system is ready to accept connections
```

### 停止
```bash
docker-compose down
```

---

## トラブルシューティング

### エラー1: "Textual SQL expression 'SELECT 1' should be explicitly declared as text('SELECT 1')"

**原因:** SQLAlchemy 2.0では文字列SQLを直接実行できない

**解決:**
```python
from sqlalchemy import text
db.execute(text("SELECT 1"))  # ✅ text()でラップ
```

### エラー2: "fastapi" コンテナが起動失敗

**確認ポイント:**
1. `compose.yml` に `version: '3.8'` があるか
2. `Dockerfile` が `database.py` をコピーしているか
3. `main.py` が `from database import SessionLocal` を含むか

### エラー3: "db" コンテナが起動しない

**確認:**
```bash
docker-compose logs db
```

PostgreSQL起動ログを確認してください。

---

## 学習ポイント（重要）

✅ **Docker Compose の depends_on + healthcheck**
- サービス間の起動順序制御が重要
- 接続エラー防止

✅ **SQLAlchemy 2.0 の変更点**
- 文字列SQLは `text()` でラップ必須
- セッション管理は自動化できる

✅ **環境変数の活用**
- `os.getenv()` で接続情報を外部化
- ホスト側とコンテナ内でホスト名が異なる
  - コンテナ内: `db` （service名）
  - ホスト側: `localhost` または `127.0.0.1`

✅ **Dockerfile のファイルコピー**
- importされるすべてのファイルをコピーする必要あり

---

## 次のステップ

フェーズ2：データモデル設計
- ユーザー管理テーブル用の ORM モデル定義
- SQLAlchemy モデルの作成方法

---

完成日: 2025-11-05
