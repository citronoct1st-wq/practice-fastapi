# FastAPI × PostgreSQL フェーズ2 データモデル設計 完了メモ

## 学習成果

✅ SQLAlchemy ORM モデルの定義方法を習得
✅ Pydantic スキーマ（バリデーション）の使用方法を理解
✅ ユーザー管理テーブル（users）の実装完了
✅ データベーステーブルの自動生成確認

---

## 実装したファイル一覧

### 1. requirements.txt - Python依存パッケージ更新

```txt
fastapi==0.104.1
uvicorn==0.24.0
python-dotenv==1.0.0

sqlalchemy==2.0.23          # ORM フレームワーク
psycopg2-binary==2.9.9      # PostgreSQL用ドライバー
alembic==1.12.1             # マイグレーションツール（オプション）
pydantic[email]             # ← フェーズ2で追加
```

**フェーズ2で追加したパッケージ:**

| パッケージ | 役割 |
|-----------|------|
| `pydantic[email]` | EmailStr の使用。メールアドレスのバリデーションを実装 |

---

### 2. models.py - SQLAlchemy ORM モデル定義（新規作成）

```python
from sqlalchemy import Column, Integer, String, DateTime, func
from datetime import datetime
from database import Base

class User(Base):
    """ユーザーモデル"""

    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, nullable=False, index=True)
    created_at = Column(DateTime, nullable=False, default=func.now())

    def __repr__(self):
        """デバッグ用の表示"""
        return f"<User(id={self.id}, name={self.name}, email={self.email})>"
```

**各要素の説明:**

#### クラス定義と継承
```python
class User(Base):
    __tablename__ = "users"
```
- `User`: Pythonクラス。PostgreSQLの「users」テーブルに対応
- `Base`: `database.py` の `declarative_base()` を継承
- `__tablename__`: 対応するテーブル名を指定

#### カラム定義

##### プライマリキー（id）
```python
id = Column(Integer, primary_key=True, index=True)
```
| 設定 | 説明 |
|------|------|
| `Integer` | データ型：整数型 |
| `primary_key=True` | プライマリキー。自動採番される一意の識別子 |
| `index=True` | インデックスを作成。検索性能を向上 |

##### ユーザー名（name）
```python
name = Column(String, nullable=False)
```
| 設定 | 説明 |
|------|------|
| `String` | データ型：可変長文字列 |
| `nullable=False` | NOT NULL制約。必須フィールド |

##### メールアドレス（email）
```python
email = Column(String, unique=True, nullable=False, index=True)
```
| 設定 | 説明 |
|------|------|
| `String` | データ型：可変長文字列 |
| `unique=True` | UNIQUE制約。重複を禁止 |
| `nullable=False` | NOT NULL制約。必須フィールド |
| `index=True` | インデックスを作成。検索性能を向上 |

##### 作成日時（created_at）
```python
created_at = Column(DateTime, nullable=False, default=func.now())
```
| 設定 | 説明 |
|------|------|
| `DateTime` | データ型：日時 |
| `nullable=False` | NOT NULL制約 |
| `default=func.now()` | 新規レコード作成時に自動的に現在時刻を設定 |

#### メソッド定義
```python
def __repr__(self):
    """デバッグ用の表示"""
    return f"<User(id={self.id}, name={self.name}, email={self.email})>"
```
- Pythonの特殊メソッド。`print(user)` で見やすい形式で表示
- **表示例:** `<User(id=1, name=山田太郎, email=yamada@example.com)>`

**テーブル構造イメージ:**

```
┌────────────────────────────────────────┐
│            users テーブル               │
├────────────────────────────────────────┤
│ id  │ name     │ email           │ created_at         │
├─────┼──────────┼─────────────────┼────────────────────┤
│ 1   │ 山田太郎 │ yamada@example  │ 2025-11-06 12:00:00│
│ 2   │ 田中花子 │ tanaka@example  │ 2025-11-06 12:05:00│
└────────────────────────────────────────┘
```

---

### 3. schemas.py - Pydantic スキーマ定義（新規作成）

```python
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

class UserCreate(BaseModel):
    """ユーザー作成時のリクエストボディ"""
    name: str
    email: EmailStr  # メール形式バリデーション付き

    class Config:
        json_schema_extra = {
            "example": {
                "name": "山田太郎",
                "email": "yamada@example.com"
            }
        }


class UserUpdate(BaseModel):
    """ユーザー更新時のリクエストボディ"""
    name: Optional[str] = None
    email: Optional[EmailStr] = None

    class Config:
        json_schema_extra = {
            "example": {
                "name": "山田次郎",
                "email": "yamada.jiro@example.com"
            }
        }


class UserResponse(BaseModel):
    """ユーザー取得時のレスポンス"""
    id: int
    name: str
    email: str
    created_at: datetime

    class Config:
        from_attributes = True  # SQLAlchemyモデルを変換可能にする
        json_schema_extra = {
            "example": {
                "id": 1,
                "name": "山田太郎",
                "email": "yamada@example.com",
                "created_at": "2025-11-05T12:34:56"
            }
        }
```

**各スキーマの役割と説明:**

#### UserCreate（ユーザー作成用リクエストスキーマ）

```python
class UserCreate(BaseModel):
    name: str
    email: EmailStr
```

**使用場面:** `POST /users` エンドポイント

**バリデーション内容:**
```
name: str
└─ 文字列であることを必須化

email: EmailStr
└─ 有効なメール形式であることを必須化
   例：✅ user@example.com
      ❌ user  （メール形式ではない）
      ❌ user@  （不完全）
```

**リクエスト例:**
```json
{
  "name": "山田太郎",
  "email": "yamada@example.com"
}
```

**バリデーション失敗例:**
```json
{
  "name": "山田太郎",
  "email": "invalid-email"  // ❌ エラー：メール形式ではない
}
```

#### UserUpdate（ユーザー更新用リクエストスキーマ）

```python
class UserUpdate(BaseModel):
    name: Optional[str] = None
    email: Optional[EmailStr] = None
```

**使用場面:** `PUT /users/{id}` エンドポイント

**特徴（Optional = 任意フィールド）:**
- `name` のみ更新：✅ 可能
- `email` のみ更新：✅ 可能
- 両方更新：✅ 可能
- 両方省略：❌ エラー（最低1つは必須）

**リクエスト例1（名前のみ更新）:**
```json
{
  "name": "山田次郎"
}
```

**リクエスト例2（メールのみ更新）:**
```json
{
  "email": "yamada.new@example.com"
}
```

#### UserResponse（レスポンススキーマ）

```python
class UserResponse(BaseModel):
    id: int
    name: str
    email: str
    created_at: datetime

    class Config:
        from_attributes = True
```

**使用場面:** すべての取得エンドポイントのレスポンス返却

**重要設定：from_attributes = True**

```python
# from_attributes = True の効果

# ケース1：設定なし
user = db.query(User).first()  # SQLAlchemyモデル
response = UserResponse(
    id=user.id,                # 手動で値をマッピング
    name=user.name,
    email=user.email,
    created_at=user.created_at
)

# ケース2：from_attributes = True 有効
user = db.query(User).first()  # SQLAlchemyモデル
response = UserResponse.from_orm(user)  # 自動変換（便利！）
```

**レスポンス例:**
```json
{
  "id": 1,
  "name": "山田太郎",
  "email": "yamada@example.com",
  "created_at": "2025-11-06T12:34:56"
}
```

**schema.py の全体構図:**

```
リクエスト処理の流れ
  ↓
①クライアント送信
  ↓
②FastAPI が UserCreate でバリデーション
  ↓
③バリデーション成功 → Pythonの辞書に変換
  ↓
④SQLAlchemyで DB操作
  ↓
⑤結果を User オブジェクトで取得
  ↓
⑥UserResponse で変換してクライアントに返送
  ↓
レスポンス返却完了
```

---

### 4. main.py - テーブル自動生成機能追加

```python
from fastapi import FastAPI
from database import SessionLocal
from sqlalchemy import text

from fastapi import FastAPI
from database import engine, Base
from models import User

# アプリケーション起動時にテーブルを自動生成
Base.metadata.create_all(bind=engine)
app = FastAPI()

@app.get("/")
def read_root():
    return {"message": "Hello, Docker + FastAPI!"}

@app.get("/items/{item_id}")
def read_item(item_id: int, q: str = None):
    return {"item_id": item_id, "q": q}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)


@app.on_event("startup")
def startup():
    db = SessionLocal()
    try:
        db.execute(text("SELECT 1"))
        print("✓ Database connected successfully!")
    finally:
        db.close()
```

**フェーズ2で追加・修正した箇所:**

#### テーブル自動生成
```python
from database import engine, Base
from models import User

# アプリケーション起動時にテーブルを自動生成
Base.metadata.create_all(bind=engine)
```

| 行 | 説明 |
|----|------|
| `from database import engine, Base` | DB接続情報と ORM基底クラスをインポート |
| `from models import User` | ユーザーモデルをインポート（テーブル自動生成に必要） |
| `Base.metadata.create_all(bind=engine)` | `models.py` で定義したすべてのテーブルを自動生成 |

**動作フロー:**

```
FastAPI アプリケーション起動
  ↓
Base.metadata.create_all(bind=engine) 実行
  ↓
User モデルを検査
  ↓
"users" テーブルが未存在か確認
  ↓
存在しない → テーブルを自動生成 ✓
存在する → スキップ
  ↓
アプリケーション起動完了
```

**重要ポイント:**
- `create_all()` は既存テーブルを削除しない
- 開発時は非常に便利（テーブル作成の手動化が不要）
- 本番環境ではAlembic（マイグレーション）の使用を推奨

---

## SQLAlchemy モデル vs Pydantic スキーマ

フェーズ2で2つの異なる定義が登場しました。違いを理解することが重要です。

### 比較表

| 項目 | SQLAlchemy モデル | Pydantic スキーマ |
|------|-----------------|-----------------|
| **定義場所** | `models.py` | `schemas.py` |
| **役割** | データベーステーブル構造を定義 | APIのリクエスト・レスポンスを定義 |
| **継承元** | `Base`（declarative_base） | `BaseModel` |
| **バリデーション** | DB制約レベル | アプリケーションレベル |
| **使用対象** | DB操作（Query, Insert, Update） | HTTP通信（JSON） |

### 使用流れのイメージ

```
ユーザーがAPIにリクエスト送信
  ↓
{"name": "山田太郎", "email": "yamada@example.com"}
  ↓
FastAPI が Pydantic スキーマで バリデーション
  ↓
UserCreate スキーマで検証
  └─ name が文字列か？✓
  └─ email がメール形式か？✓
  ↓
バリデーション成功
  ↓
SQLAlchemy モデル (User) で DB操作
  ↓
db.add(User(name="山田太郎", email="yamada@example.com"))
db.commit()
  ↓
SQLAlchemy が users テーブルにINSERT
  ↓
レスポンス作成（UserResponse で変換）
  ↓
{"id": 1, "name": "山田太郎", ...}
  ↓
クライアントにレスポンス返却
```

---

## テーブル確認方法（PostgreSQL）

### コンテナに接続

```bash
docker-compose exec db psql -U postgres -d fastapi_db
```

### テーブル一覧表示

```sql
\dt
```

**出力例:**
```
          List of relations
 Schema | Name  | Type  |  Owner
--------+-------+-------+----------
 public | users | table | postgres
(1 row)
```

### users テーブルの詳細確認

```sql
\d users
```

**出力例:**
```
                    Table "public.users"
  Column   |            Type             | Collation | Nullable | Default
-----------+-----------------------------+-----------+----------+---------
 id        | integer                     |           | not null |
 name      | character varying           |           | not null |
 email     | character varying           |           | not null |
 created_at| timestamp without time zone |           | not null | now()

Indexes:
    "users_pkey" PRIMARY KEY, btree (id)
    "ix_users_email" UNIQUE, btree (email)
    "ix_users_id" btree (id)
```

### テーブル削除（初期化が必要な場合のみ）

```sql
DROP TABLE users;
```

### PostgreSQL 終了

```
\q
```

---

## トラブルシューティング

### エラー1: "ModuleNotFoundError: No module named 'models'"

**原因:**
1. `models.py` が作成されていない
2. `Dockerfile` が `models.py` をコピーしていない

**解決:**
```dockerfile
# Dockerfile に以下を追加
COPY models.py .
COPY schemas.py .
```

```bash
docker-compose up --build
```

### エラー2: "cannot import name 'EmailStr'"

**原因:** `pydantic[email]` がインストールされていない

**解決:**
```txt
# requirements.txt に以下を追加
pydantic[email]
```

```bash
docker-compose up --build
```

### エラー3: "ProgrammingError: relation 'users' does not exist"

**原因:** `Base.metadata.create_all()` が実行されていない

**確認:**
```python
# main.py の冒頭に以下があるか確認
Base.metadata.create_all(bind=engine)
```

### エラー4: "IntegrityError: duplicate key value violates unique constraint 'ix_users_email'"

**原因:** 同じメールアドレスで複数ユーザーを登録しようとした

**解決:**
```bash
# テーブルを初期化
docker-compose exec db psql -U postgres -d fastapi_db
# psql> DROP TABLE users;
# psql> \q

docker-compose restart fastapi
```

---

## ファイル構成確認（フェーズ2完了時）

```
practice-fastapi/
├── Dockerfile                              ← models.py, schemas.py 追加
├── compose.yml
├── requirements.txt                        ← pydantic[email] 追加
├── main.py                                 ← Base.metadata.create_all() 追加
├── database.py                             （変更なし）
├── models.py                               ← フェーズ2 新規作成
├── schemas.py                              ← フェーズ2 新規作成
├── .gitignore
├── 学習メモ.md
├── カリキュラム_DB連携.md
├── 学習メモ_フェーズ1完了.md
├── カリキュラム_フェーズ2_データモデル設計.md
└── 学習メモ_フェーズ2完了.md                ← 本ファイル
```

### Dockerfile の確認

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY main.py .
COPY database.py .
COPY models.py .          # ← 必須
COPY schemas.py .         # ← 必須

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

---

## 学習ポイント（重要）

✅ **SQLAlchemy ORM モデル定義**
- テーブル構造をPythonクラスで表現
- 制約（UNIQUE, NOT NULL等）をカラム定義に組み込む
- インデックス作成で検索性能を向上

✅ **Pydantic バリデーション**
- APIのリクエスト・レスポンスを型安全に定義
- `EmailStr` でメール形式チェック自動化
- `Optional[]` で任意フィールドを実装

✅ **from_attributes = True の効果**
- SQLAlchemy モデルを Pydantic スキーマに自動変換
- ORMとAPIの橋渡し役

✅ **テーブル自動生成**
- `Base.metadata.create_all()` で開発効率化
- 本番環境では Alembic 使用推奨

✅ **データ型と制約の関係性**
```
models.py（DB制約）     schemas.py（API検証）
id: Integer          →  id: int
email: String        →  email: EmailStr
unique=True          →  （スキーマに反映）
```

---

## 次のステップ（フェーズ3の予告）

フェーズ3では **CRUD エンドポイント実装** を行います：

### 実装するエンドポイント

```
POST   /users          → ユーザー作成（CREATE）
GET    /users          → 全ユーザー取得（READ）
GET    /users/{id}     → 特定ユーザー取得（READ）
PUT    /users/{id}     → ユーザー更新（UPDATE）
DELETE /users/{id}     → ユーザー削除（DELETE）
```

### 実装内容

- パラメータバリデーション
- エラーハンドリング（404 Not Found, 409 Conflict等）
- トランザクション処理
- HTTPステータスコード適切な割り当て

---

## 学習のコツ

✅ **試行錯誤を大切に**
- エラーメッセージをしっかり読む
- `docker-compose logs fastapi` でログ確認
- `print()` デバッグで値の流れを追跡

✅ **ドキュメント活用**
- SQLAlchemy 公式: https://docs.sqlalchemy.org/
- Pydantic 公式: https://docs.pydantic.dev/
- FastAPI 公式: https://fastapi.tiangolo.com/

✅ **PostgreSQL で実際の状態を確認**
- `psql` でテーブル構造を視認
- INSERT/SELECT で動作確認
- DB側の制約動作を理解

✅ **モデル → スキーマの対応を理解する**
- models.py：「何をDB保存するか」
- schemas.py：「どうバリデーションするか」
- 分けて考えることで設計が明確になる

---

## Dockerfile 修正チェックリスト

フェーズ2 完了時点で、Dockerfile に以下が含まれているか確認：

```dockerfile
✅ COPY models.py .
✅ COPY schemas.py .
```

含まれていない場合は追加して再度ビルドしてください：

```bash
docker-compose down
docker-compose up --build
```

---

## 動作確認コマンド一覧

### アプリケーションの起動

```bash
docker-compose down
docker-compose up --build
```

### ログ確認（テーブル自動生成を確認）

```bash
docker-compose logs fastapi
```

**期待されるログ:**
```
✓ Database connected successfully!
INFO:     Application startup complete
```

### PostgreSQL でテーブル確認

```bash
docker-compose exec db psql -U postgres -d fastapi_db -c "\d users"
```

### ログ終了時のクリーンアップ

```bash
docker-compose down
```

---

## 完了の確認

フェーズ2 完了条件（すべて ✅ か確認）：

- [x] `models.py` を作成（User モデル定義）
- [x] `schemas.py` を作成（UserCreate, UserUpdate, UserResponse）
- [x] `requirements.txt` に `pydantic[email]` を追加
- [x] `main.py` に `Base.metadata.create_all()` を追加
- [x] `Dockerfile` に `COPY models.py .` と `COPY schemas.py .` を追加
- [x] `docker-compose up --build` が成功
- [x] PostgreSQL で `users` テーブルが存在確認

**すべての項目が ✅ であれば、フェーズ2 完了！**

---

完成日: 2025-11-06
フェーズ: 2/3 完了

次へ → フェーズ3: CRUD エンドポイント実装
