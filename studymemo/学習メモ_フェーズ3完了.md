# FastAPI × PostgreSQL フェーズ3 CRUD エンドポイント実装 完了メモ

## 学習成果

✅ CRUD エンドポイント（Create, Read, Update, Delete）の実装完了
✅ HTTPステータスコードの正しい使い分け
✅ エラーハンドリング（404, 409 Conflict など）を実装
✅ SQLAlchemy トランザクション処理を習得
✅ routers フォルダによる実践的なファイル分割
✅ APIRouter による保守性の高いエンドポイント設計

---

## 実装したファイル一覧

### 1. main.py - アプリケーション初期化（修正）

```python
from fastapi import FastAPI
from database import engine, Base, SessionLocal
from sqlalchemy import text
from routers import users  # ← ルータをインポート

# テーブル自動生成
Base.metadata.create_all(bind=engine)

# FastAPI アプリケーション作成
app = FastAPI(
    title="User Management API",
    description="ユーザー管理API",
    version="1.0.0"
)

# ルータを登録（エンドポイントを組み込む）
app.include_router(users.router)

# DB接続確認（起動時実行）
@app.on_event("startup")
def startup():
    db = SessionLocal()
    try:
        db.execute(text("SELECT 1"))
        print("✓ Database connected successfully!")
    finally:
        db.close()
```

**フェーズ3での修正ポイント:**

| 項目 | 説明 |
|------|------|
| `from routers import users` | routers フォルダから users モジュールをインポート |
| `app.include_router(users.router)` | APIRouter をアプリケーションに登録 |
| `title`, `description`, `version` | FastAPI メタデータ設定（Swagger UIに表示） |

**責務の分離:**
- `main.py`: アプリケーション初期化のみ
- `routers/users.py`: エンドポイント実装
- エンドポイント実装がない → ファイルが短く読みやすい

---

### 2. routers/__init__.py - パッケージ化ファイル（新規作成）

```python
# routers/__init__.py
# パッケージ化するための空ファイル
```

**役割:**
- Python でフォルダをパッケージとして認識させる
- `from routers import users` のインポートを可能にする

---

### 3. routers/users.py - ユーザーエンドポイント実装（新規作成）

```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from database import get_db
from models import User
from schemas import UserCreate, UserResponse, UserUpdate

router = APIRouter(prefix="/users", tags=["users"])

# ここに5つのエンドポイントを実装
```

#### 3-1. CREATE エンドポイント（POST /users）

```python
@router.post("", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def create_user(user: UserCreate, db: Session = Depends(get_db)):
    """ユーザー作成エンドポイント

    Args:
        user: ユーザー作成用スキーマ（name, email）
        db: データベースセッション（自動注入）

    Returns:
        UserResponse: 作成されたユーザー情報

    Raises:
        HTTPException 409: メールアドレスが既に登録されている
    """
    try:
        # 新規 User オブジェクト作成
        db_user = User(name=user.name, email=user.email)

        # データベースに追加（トランザクション開始）
        db.add(db_user)

        # コミット（実際にDB反映）
        db.commit()

        # 作成されたレコードを再取得（id, created_at 等が反映される）
        db.refresh(db_user)

        return db_user

    except IntegrityError:
        # トランザクション状態をリセット
        db.rollback()

        # クライアントにエラー返却（409 Conflict）
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="メールアドレスは既に登録されています"
        )
```

**トランザクション処理フロー:**

```
1. db.add(db_user)
   ↓
   メモリ上に User オブジェクト追加（未確定）

2. db.commit()
   ↓
   INSERT文を実行
   トランザクションを確定

3. db.refresh(db_user)
   ↓
   DB から最新データを再取得
   自動採番 id, created_at 等が反映

4. return db_user
   ↓
   レスポンスとして返却（201 Created）
```

**エラーハンドリング:**
- `IntegrityError`: email の UNIQUE 制約違反を検出
- `db.rollback()`: トランザクションを取り消し
- `409 Conflict`: メール重複エラーを返す

---

#### 3-2. READ エンドポイント（GET /users）

```python
@router.get("", response_model=list[UserResponse])
def read_users(db: Session = Depends(get_db)):
    """全ユーザー取得エンドポイント

    Returns:
        list[UserResponse]: ユーザ情報のリスト
    """
    users = db.query(User).all()
    return users
```

**SQL生成:**
```sql
SELECT * FROM users;
```

**レスポンス例:**
```json
[
  {
    "id": 1,
    "name": "山田太郎",
    "email": "yamada@example.com",
    "created_at": "2025-11-06T12:00:00"
  },
  {
    "id": 2,
    "name": "田中花子",
    "email": "tanaka@example.com",
    "created_at": "2025-11-06T12:05:00"
  }
]
```

---

#### 3-3. READ エンドポイント（GET /users/{user_id}）

```python
@router.get("/{user_id}", response_model=UserResponse)
def read_user(user_id: int, db: Session = Depends(get_db)):
    """特定ユーザ取得エンドポイント

    Args:
        user_id: ユーザID（パスパラメータ）
        db: データベースセッション

    Returns:
        UserResponse: ユーザ情報

    Raises:
        HTTPException 404: ユーザが見つからない
    """
    # IDで検索
    db_user = db.query(User).filter(User.id == user_id).first()

    # ユーザが存在しない場合はエラー
    if not db_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ユーザが見つかりません"
        )

    return db_user
```

**SQL生成:**
```sql
SELECT * FROM users WHERE id = 1 LIMIT 1;
```

**エラーハンドリング:**
- `.first()`: None を返す（レコード未検出時）
- 404 Not Found: 存在しないユーザー ID で 404 を返す

**レスポンス例:**
```json
{
  "id": 1,
  "name": "山田太郎",
  "email": "yamada@example.com",
  "created_at": "2025-11-06T12:00:00"
}
```

---

#### 3-4. UPDATE エンドポイント（PUT /users/{user_id}）

```python
@router.put("/{user_id}", response_model=UserResponse)
def update_user(
    user_id: int,
    user_update: UserUpdate,
    db: Session = Depends(get_db)
):
    """ユーザ更新エンドポイント

    Args:
        user_id: ユーザID（パスパラメータ）
        user_update: 更新内容(name, email は任意)
        db: データベースセッション

    Returns:
        UserResponse: 更新されたユーザ情報

    Raises:
        HTTPException 404: ユーザが見つからない
        HTTPException 409: 新しいメールが既に登録されている
    """
    # 対象ユーザを取得
    db_user = db.query(User).filter(User.id == user_id).first()

    # ユーザが存在しない場合はエラー
    if not db_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ユーザが見つかりません"
        )

    try:
        # 更新フィールドのみ反映（None 以外）
        if user_update.name is not None:
            db_user.name = user_update.name

        if user_update.email is not None:
            db_user.email = user_update.email

        # コミット
        db.commit()

        # 更新後のデータを再取得
        db.refresh(db_user)

        return db_user

    except IntegrityError:
        db.rollback()

        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail="メールアドレスは既に登録されています"
        )
```

**Optional フィールドの処理:**
```python
if user_update.name is not None:
    db_user.name = user_update.name
```

- `UserUpdate` スキーマで `Optional` を使用
- `None` チェックで指定されたフィールドのみ更新
- 提供されないフィールドは変更しない

**リクエスト例（名前のみ更新）:**
```json
{
  "name": "山田次郎"
}
```

**DB反映後:**
```
id=1
name=山田次郎    （更新）
email=yamada@example.com  （変更なし）
```

---

#### 3-5. DELETE エンドポイント（DELETE /users/{user_id}）

```python
@router.delete("/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_user(user_id: int, db: Session = Depends(get_db)):
    """ユーザ削除エンドポイント

    Args:
        user_id: ユーザID（パスパラメータ）
        db: データベースセッション

    Raises:
        HTTPException 404: ユーザが見つかりません
    """
    # 対象ユーザを取得
    db_user = db.query(User).filter(User.id == user_id).first()

    # ユーザが存在しない場合エラー
    if not db_user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="ユーザが見つかりません"
        )

    # データベースから削除
    db.delete(db_user)

    # コミット
    db.commit()

    # 204 No Content なのでレスポンスボディは返さない
```

**SQL生成:**
```sql
DELETE FROM users WHERE id = 1;
```

**特徴:**
- `status_code=204`: 削除成功時に 204 No Content を返す
- レスポンスボディなし（`response_model` を指定しない）
- RESTful API の慣例に従う

---

### 4. Dockerfile - コンテナビルド定義（修正）

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY main.py .
COPY database.py .
COPY models.py .
COPY schemas.py .
COPY routers .          # ← routers フォルダを追加

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**フェーズ3での修正:**

| 項目 | 説明 |
|------|------|
| `COPY routers .` | routers フォルダ全体をコンテナ内にコピー |

**コピー対象:**
- `routers/__init__.py`
- `routers/users.py`

---

## ファイル構成（フェーズ3完了時）

```
practice-fastapi/
├── Dockerfile                              ✅ routers追加
├── compose.yml                             （変更なし）
├── requirements.txt                        （変更なし）
├── main.py                                 ✅ 修正（シンプル化）
├── database.py                             （変更なし）
├── models.py                               （変更なし）
├── schemas.py                              （変更なし）
├── routers/                                ✅ 新規フォルダ
│   ├── __init__.py                        ✅ 新規（パッケージ化）
│   └── users.py                           ✅ 新規（5つのエンドポイント）
├── .gitignore                              （変更なし）
└── studymemo/
    ├── 学習メモ_フェーズ1完了.md
    ├── 学習メモ_フェーズ2完了.md
    └── 学習メモ_フェーズ3完了.md            ← 本ファイル
```

---

## エンドポイント実装まとめ

### APIRouter の利点

```python
router = APIRouter(prefix="/users", tags=["users"])

@router.post("")  # 実際のエンドポイント: POST /users
@router.get("")   # 実際のエンドポイント: GET /users
@router.get("/{user_id}")  # 実際のエンドポイント: GET /users/{user_id}
```

| 利点 | 説明 |
|------|------|
| **prefix 自動付与** | `/users` を全エンドポイントに自動追加 |
| **tags 分類** | Swagger UI で「users」カテゴリに分類 |
| **保守性向上** | エンドポイント集約ファイル化 |
| **再利用性** | 複数の APIRouter を app に登録可能 |

---

## HTTPステータスコードの使い分け

| メソッド | エンドポイント | ステータス | 意味 |
|---------|--------------|----------|------|
| `POST` | `/users` | `201` | Created（新規作成成功） |
| `GET` | `/users` | `200` | OK（取得成功） |
| `GET` | `/users/{id}` | `200` | OK（取得成功） |
| `GET` | `/users/{id}` | `404` | Not Found（リソース未検出） |
| `PUT` | `/users/{id}` | `200` | OK（更新成功） |
| `PUT` | `/users/{id}` | `404` | Not Found（リソース未検出） |
| `PUT` | `/users/{id}` | `409` | Conflict（メール重複） |
| `DELETE` | `/users/{id}` | `204` | No Content（削除成功） |
| `DELETE` | `/users/{id}` | `404` | Not Found（リソース未検出） |

### ステータスコードの意味

```
1xx（100-199）  情報（サーバー側の処理進捗）
2xx（200-299）  成功 ← 正常系を使用
3xx（300-399）  リダイレクト
4xx（400-499）  クライアントエラー ← エラー系を使用
5xx（500-599）  サーバーエラー
```

---

## トランザクション処理の重要性

### トランザクション 3段階

```
db.add(db_user)     # フェーズ1: 準備
    ↓
db.commit()         # フェーズ2: 確定（INSERT/UPDATE/DELETE実行）
    ↓
db.refresh(db_user) # フェーズ3: 再取得（自動生成値を反映）
```

### IntegrityError ハンドリング

```python
try:
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

except IntegrityError:
    db.rollback()  # トランザクション取り消し
    raise HTTPException(...)
```

**重要:**
- 制約違反時に `IntegrityError` 例外が発生
- `db.rollback()` で部分的な更新を防ぐ
- クライアントに 409 Conflict を返す

---

## Swagger UI での動作確認

### アクセス方法
```
http://localhost:8000/docs
```

### テストフロー

1. **POST /users** でユーザー作成（201 Created）
2. **GET /users** で全ユーザー確認（200 OK）
3. **GET /users/{id}** で個別取得確認（200 OK）
4. **PUT /users/{id}** で更新確認（200 OK）
5. **DELETE /users/{id}** で削除確認（204 No Content）

### エラーケーステスト

- **同じメールで POST**: 409 Conflict
- **存在しないID で GET**: 404 Not Found
- **存在しないID で PUT**: 404 Not Found
- **存在しないID で DELETE**: 404 Not Found

---

## APIRouter の責務分離パターン

### フェーズ3での実装

```
main.py
├─ アプリケーション初期化
├─ テーブル自動生成
├─ ルータ登録
└─ 起動時処理

routers/users.py
├─ APIRouter 定義
├─ POST /users（CREATE）
├─ GET /users（READ全体）
├─ GET /users/{id}（READ個別）
├─ PUT /users/{id}（UPDATE）
└─ DELETE /users/{id}（DELETE）
```

### 将来の拡張例

```
routers/
├─ __init__.py
├─ users.py       （ユーザー関連：5エンドポイント）
├─ products.py    （商品関連：複数エンドポイント）
├─ orders.py      （注文関連：複数エンドポイント）
└─ auth.py        （認証関連：複数エンドポイント）

main.py
├─ app.include_router(users.router)
├─ app.include_router(products.router)
├─ app.include_router(orders.router)
└─ app.include_router(auth.router)
```

---

## よくあるエラーと解決方法

### エラー1: "ModuleNotFoundError: No module named 'routers'"

**原因:** `routers/__init__.py` が作成されていない

**解決:**
```bash
# routers/__init__.py を作成（空ファイルでOK）
touch routers/__init__.py
```

---

### エラー2: "405 Method Not Allowed"

**原因:** リクエストメソッド（POST, GET等）が間違っている

**確認:**
```
POST /users     ✅ 正しい
GET /users      ✅ 正しい
POST /users/{id} ❌ 正しくない（DELETE または PUT を使用）
```

---

### エラー3: "409 Conflict"（メール重複）

**原因:** 同じメールアドレスで複数ユーザーを作成

**解決:**
```bash
# テーブルをリセット
docker-compose exec db psql -U postgres -d fastapi_db
# psql> DELETE FROM users;
# psql> \q
```

---

### エラー4: "422 Unprocessable Entity"

**原因:** リクエストボディのバリデーション失敗

**確認:**
```json
// ❌ メール形式が不正
{
  "name": "山田太郎",
  "email": "invalid-email"
}

// ✅ 正しいメール形式
{
  "name": "山田太郎",
  "email": "yamada@example.com"
}
```

---

## 学習のポイント

✅ **責務分離の重要性**
- `main.py`: アプリケーション初期化のみ
- `routers/users.py`: エンドポイント実装
- 役割を分ける → コードが読みやすい

✅ **トランザクション処理**
- add → commit → refresh の流れを理解
- IntegrityError で制約違反をキャッチ
- rollback で部分的な更新を防止

✅ **HTTPステータスコード**
- 201: 新規作成成功
- 200: 取得・更新成功
- 204: 削除成功
- 404: リソース未検出
- 409: リソース競合

✅ **Optional フィールド**
- UserUpdate で複数フィールドを任意化
- None チェックで指定フィールドのみ更新

✅ **APIRouter の活用**
- prefix で自動的にパスを付与
- tags で Swagger UI を分類
- スケーラビリティが向上

---

## 動作確認コマンド

### ビルド・起動
```bash
docker-compose down
docker-compose up --build
```

### ログ確認
```bash
docker-compose logs fastapi
```

### Swagger UI にアクセス
```
http://localhost:8000/docs
```

### PostgreSQL でテーブル確認
```bash
docker-compose exec db psql -U postgres -d fastapi_db -c "SELECT * FROM users;"
```

### 停止
```bash
docker-compose down
```

---

## 次のステップ（フェーズ4の予告）

フェーズ4では以下を実装します：

- **パスワード認証機能**
  - パスワードハッシュ化（bcrypt）
  - パスワード検証

- **JWT トークン発行・検証**
  - ログイン エンドポイント実装
  - アクセストークン生成

- **ロールベースアクセス制御（RBAC）**
  - 管理者・ユーザー権限分離
  - エンドポイント保護

- **セキュアなデータベース操作**
  - SQLインジェクション対策
  - 機密情報の非表示

---

## 完成日

**フェーズ3完了日:** 2025-11-06
**進捗:** 3/4 フェーズ完了

**次フェーズへ:** フェーズ4 認証・認可とセキュリティ

---

## 参考リンク

- FastAPI 公式: https://fastapi.tiangolo.com/
- SQLAlchemy 公式: https://docs.sqlalchemy.org/
- HTTP ステータスコード: https://developer.mozilla.org/ja/docs/Web/HTTP/Status
- Pydantic 公式: https://docs.pydantic.dev/

---

お疲れ様でした！フェーズ3を完了しました 🎉
